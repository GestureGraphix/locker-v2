"use strict";exports.id=247,exports.ids=[247],exports.modules={3247:(e,t,r)=>{r.d(t,{memoryAdapter:()=>a});var n=r(6714),l=r(9601);let a=(e,t)=>{let r=null,a=(0,l.II)({config:{adapterId:"memory",adapterName:"Memory Adapter",usePlural:!1,debugLogs:t?.debugLogs||!1,supportsArrays:!0,customTransformInput:t=>(t.options.advanced?.database?.useNumberId||t.options.advanced?.database?.generateId==="serial")&&"id"===t.field&&"create"===t.action?e[t.model].length+1:t.data,transaction:async t=>{let n=structuredClone(e);try{return await t(a(r))}catch(t){throw Object.keys(e).forEach(t=>{e[t]=n[t]}),t}}},adapter:({getFieldName:t,options:r,getModelName:l})=>{let a=(e,r,n)=>r?e.sort((e,l)=>{let a=t({model:n,field:r.field}),o=e[a],s=l[a],i=0;return i=null==o&&null==s?0:null==o?-1:null==s?1:"string"==typeof o&&"string"==typeof s?o.localeCompare(s):o instanceof Date&&s instanceof Date?o.getTime()-s.getTime():"number"==typeof o&&"number"==typeof s?o-s:"boolean"==typeof o&&"boolean"==typeof s?o===s?0:o?1:-1:String(o).localeCompare(String(s)),"asc"===r.direction?i:-i}):e;function o(t,r,a){let o=(t,r)=>{let l=e[r];if(!l)throw n.vF.error(`[MemoryAdapter] Model ${r} not found in the DB`,Object.keys(e)),Error(`Model ${r} not found`);let a=(e,t)=>{let{field:r,value:n,operator:l}=t;switch(l){case"in":if(!Array.isArray(n))throw Error("Value must be an array");return n.includes(e[r]);case"not_in":if(!Array.isArray(n))throw Error("Value must be an array");return!n.includes(e[r]);case"contains":return e[r].includes(n);case"starts_with":return e[r].startsWith(n);case"ends_with":return e[r].endsWith(n);case"ne":return e[r]!==n;case"gt":return null!=n&&e[r]>n;case"gte":return null!=n&&e[r]>=n;case"lt":return null!=n&&e[r]<n;case"lte":return null!=n&&e[r]<=n;default:return e[r]===n}};return l.filter(e=>{if(!t.length||0===t.length)return!0;let r=a(e,t[0]);for(let n of t){let t=a(e,n);r="OR"===n.connector?r||t:r&&t}return r})};if(!a)return o(t,r);let s=o(t,r),i=new Map,u=new Map;for(let t of s){let r=String(t.id);if(!i.has(r)){let e={...t};for(let[t,n]of Object.entries(a)){let a=l(t);"one-to-one"===n.relation?e[a]=null:(e[a]=[],u.set(`${r}-${t}`,new Set))}i.set(r,e)}let o=i.get(r);for(let[s,i]of Object.entries(a)){let a=l(s),d=e[a];if(!d)throw n.vF.error(`[MemoryAdapter] JoinOption model ${a} not found in the DB`,Object.keys(e)),Error(`JoinOption model ${a} not found`);let c=d.filter(e=>e[i.on.to]===t[i.on.from]);if("one-to-one"===i.relation)o[a]=c[0]||null;else{let e=u.get(`${r}-${s}`),t=i.limit??100,n=0;for(let r of c){if(n>=t)break;!e.has(r.id)&&(o[a].push(r),e.add(r.id),n++)}}}}return Array.from(i.values())}return{create:async({model:t,data:n})=>((r.advanced?.database?.useNumberId||r.advanced?.database?.generateId==="serial")&&(n.id=e[l(t)].length+1),e[t]||(e[t]=[]),e[t].push(n),n),findOne:async({model:e,where:t,join:r})=>{let n=o(t,e,r);return r?n.length?n[0]:null:n[0]||null},findMany:async({model:e,where:t,sortBy:r,limit:n,offset:l,join:s})=>{let i=o(t||[],e,s);if(s){if(!i.length)return[];a(i,r,e);let t=i;return void 0!==l&&(t=t.slice(l)),void 0!==n&&(t=t.slice(0,n)),t}let u=a(i,r,e);return void 0!==l&&(u=u.slice(l)),void 0!==n&&(u=u.slice(0,n)),u||[]},count:async({model:t,where:r})=>r?o(r,t).length:e[t].length,update:async({model:e,where:t,update:r})=>{let n=o(t,e);return n.forEach(e=>{Object.assign(e,r)}),n[0]||null},delete:async({model:t,where:r})=>{let n=e[t],l=o(r,t);e[t]=n.filter(e=>!l.includes(e))},deleteMany:async({model:t,where:r})=>{let n=e[t],l=o(r,t),a=0;return e[t]=n.filter(e=>l.includes(e)?(a++,!1):!l.includes(e)),a},updateMany({model:e,where:t,update:r}){let n=o(t,e);return n.forEach(e=>{Object.assign(e,r)}),n[0]||null}}}});return e=>(r=e,a(e))}}};